根据您提供的设计文档，我将整个开发过程划分为七个清晰的阶段。每个阶段都配有一组专业提示词，可直接用于与AI协作开发，覆盖从硬件初始化到高级应用框架的全部内容。提示词聚焦核心产出，避免过度细化，以减少歧义。

---

## **阶段1：硬件分析与基础环境搭建**
**目标**：确认硬件细节，搭建ESP-IDF开发环境，验证最小系统（串口输出、LED点亮）。  
**提示词**：  
> 基于“kafkar 黄色廉价板子”的典型配置（ESP32-WROOM-32、ILI9341显示屏、XPT2046触摸、16MB外置Flash、1GB SD卡），编写一个Arduino框架下的初始化测试程序。要求：
> - 配置开发板管理URL，安装ESP32支持包。
> - 点亮板载LED（如果存在）或使用GPIO2测试。
> - 初始化串口，每秒打印“Hello from ESP32”。
> - 列出后续开发所需的硬件引脚分配（建议基于Cheap Yellow Display通用引脚定义）。

---

## **阶段2：系统框架与配置系统设计**
**目标**：实现分层架构，设计配置管理模块（ConfigManager），支持编译时默认值、NVS持久化和SD卡配置文件覆盖。  
**提示词**：  
> 依据设计文档，开发一个ConfigManager类，负责系统配置的加载与访问。要求：
> - 支持三级配置源：代码默认值 → NVS分区 → SD卡配置文件（JSON格式）。
> - 提供API：`config.getInt(section, key)`、`config.setString(section, key, value)`等。
> - 使用Preferences库操作NVS，使用ArduinoJson解析SD卡配置文件。
> - 示例配置文件应包含显示、触摸、存储、Wi-Fi等常用项。
> - 实现启动加载流程，将最终配置存储在全局可访问的单例中。


---

## **阶段3：板级支持包（BSP）开发**
**目标**：封装底层硬件驱动，为上层提供统一、简洁的BSP API，并注册到LVGL。  
**提示词**：  
> 根据设计文档的BSP接口定义，实现以下模块：
> - `bsp_init()`：总初始化函数，调用各子模块。
> - `bsp_display_init(lv_disp_drv_t *drv)`：初始化ILI9341，绑定flush回调（使用DMA传输）。
> - `bsp_touch_init(lv_indev_drv_t *drv)`：初始化XPT2046，绑定read回调（中断触发）。
> - `bsp_backlight_set(uint8_t level)`：PWM调节背光。
> - `bsp_sd_init()`：挂载SD卡，返回是否成功。
> - 所有引脚和参数从ConfigManager读取。
> - 代码需与LVGL v8.3兼容，并包含必要的头文件。

---

## **阶段4：存储系统集成**
**目标**：将SPIFFS（外置Flash）和SD卡集成到LVGL文件系统接口，实现资源加载与缓存机制。  
**提示词**：  
> 实现以下功能：
> 1. 将16MB外置Flash划分为SPIFFS分区（`lv_res`，大小7MB），并格式化为SPIFFS。
> 2. 编写LVGL文件系统驱动，为SPIFFS注册盘符`F:`，为SD卡注册盘符`S:`。
> 3. 实现一个基于LRU的内存缓存池，用于缓存从SD卡读取的图片/字体资源。缓存大小可在配置中调整。
> 4. 提供`preload_resources(screen_manifest)`函数，根据清单文件预加载资源到缓存。
> 5. 示例清单文件（JSON格式）应包含图片路径和字体路径。

---

## **阶段5：LVGL渲染性能优化与多核分配**
**目标**：配置LVGL以获得最佳性能，并将渲染任务固定到专用核心。  
**提示词**：  
> 基于设计文档的优化建议，完成以下配置：
> - 在`lv_conf.h`中启用双缓冲、局部刷新，设置VDB大小为屏幕1/10。
> - 开启LVGL内存管理器，分配64KB内存池。
> - 将关键函数（`flush_cb`等）放入IRAM（使用`IRAM_ATTR`）。
> - 创建两个FreeRTOS任务：
>   - 任务1（固定在Core 1）：以5ms周期调用`lv_timer_handler()`。
>   - 任务2（Core 0）：运行主应用逻辑（如WiFi、传感器读取）。
> - 实现`lv_tick_inc(1)`由硬件定时器（1ms周期）触发。
> - 验证屏幕刷新率是否达到60fps。

---

## **阶段6：功耗管理**
**目标**：实现动态频率调节、智能背光控制、轻度睡眠与唤醒机制。  
**提示词**：  
> 根据文档设计，添加功耗管理模块：
> - 实现一个活动监视器，跟踪用户输入和动画状态，根据空闲时间调节CPU频率（240/160/80 MHz）。
> - 实现背光智能控制：可以关闭(boot按钮控制)；可选光敏电阻自动亮度调节(为后期开发应用内调节亮度做支持).
> - 实现睡眠（Light Sleep）模式：背光关闭5分钟后，暂停LVGL定时器，关闭显示，设置boot引脚中断为唤醒源。
> - 点按boot按钮唤醒后快速恢复UI状态（重新初始化显示，恢复背光，恢复LVGL心跳,重回上次显示内容）。
> - 提供API供应用层查询当前功耗状态。

---

## **阶段7：应用框架与高级优化**
**目标**：构建App Manager，支持多应用切换及资源动态加载/卸载，实现类似移动OS的应用体验。  
**提示词**：  
> 基于文档的多App内存优化机制，实现一个轻量级应用管理器：
> - 定义应用生命周期：前台（Active）、后台（Paused）、未活动（Stopped）。
> - 应用切换时，后台应用销毁其LVGL对象，释放内存；前台应用根据保存的状态重建UI。
> - 提供`app_register()`、`app_switch()`等API。
> - 实现“界面清单”预加载机制：当用户点击某个应用图标时，预加载器在后台加载该应用所需的资源（图片、字体）。
> - 确保切换过程流畅，无明显延迟。
> - 构建系统应用：一个基础的“设置”界面，包含亮度调节等配置项编辑功能。

---

以上七个阶段覆盖了从底层硬件初始化到上层应用框架的全部开发内容。每个提示词均基于设计文档的核心思想，可直接用于与AI对话生成代码或配置。如需进一步细化某阶段，可在提示词后补充具体硬件型号或偏好库。